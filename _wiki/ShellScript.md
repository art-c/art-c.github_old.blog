---
layout  : wiki
title   : ShellScript
summary : ShellScript 배우기
date    : 2020-01-15 23:59:22 +0900
updated : 2020-07-07 00:48:20 +0900
tag     : shell shellscript 쉘스크립트 
toc     : true
public  : true
parent  : Script
latex   : false
---
* TOC
{:toc}

# ShellScript

## 쉘스크립트 if문
```sh
if [ 값 조건식 값2 ];then
코드
fi
```
* 주의할 점 : [, ], 조건 모두  양 옆 한 칸 꼭 띄어쓰기,
* 조건문 종류

```sh
[ -z ] : 문자열의 길이가 0이면 참
[ -n ] : 문자열의 길이가 0이 아니면 참
[ -eq ] : 값이 같으면 참
[ -ne ] : 값이 다르면 참
[ -gt ] :  값1 > 값2
[ -ge ] : 값1  >= 값2
[ -lt ] : 값1 < 값2
[ -le ] : 값1 <= 값2

[ -a ] : &&연산과 동일 and 연산
[ -o ] : ||연산과 동일 xor 연산

[ -d ] : 파일이 디렉토리면 참
[ -e ] : 파일이 있으면 참
[ -L ] : 파일이 심볼릭 링크면 참
[ -r ] : 파일이 읽기 가능하면 참
[ -s ] : 파일의 크기가 0 보다 크면 참
[ -w ] : 파일이 쓰기 가능하면 참
[ -x ] : 파일이 실행 가능하면 참

[ 파일1 -nt 파일2 ]  : 파일1이 파일2보다 최신파일이면 참
[ 파일1 -ot 파일2 ]  : 파일1이 파일2보다 이전파일이면 참
[ 파일1 -ef 파일2 ] : 파일1이 파일2랑 같은 파일이면 참
```

## 인자값 받기
* $1 : 첫 번째 인자
* $# : 인자 개수
* $@ : all 인자

```sh
```

## 리스트 사용하기
* valueName="1 2 3 4 5 6 7"

## expr 표현식
* expr 다음 공백이 한칸 있어야 하며 표현식이 오면 표현식을 계산한다.
* 표현식 내에서도 공백필요: expr 1 + 1 / 2
* 특수 문자는 이스케이프 필요 expr 2 "*" 3
* 

## /dev/null
* 출력을 잡솨드시는 /dev/null, 출력계의 먹개비.
* 입출력의 종류와 대응되는 숫자는 다음과 같음.
```
0 표준 입력
1 표준 출력
2 표준 오류 출력
```
* 사용예제 
```sh
표준 출력 무시
echo hi > /dev/null

표준 오류 출력 무시
ech hi 2> /dev/null

표준 출력 표준 오류 출력 둘 다 무시.
`echo hi > /dev/null 2>&1`

1> 은 표준 출력의 방향이며 1> /dev/null은 표준 출력을 먹개비한테 돌린다는 의미,

2> 역시 마찬가지며 1>에서 1은 보통 생략(기본값)

출력 오류가 있을 때 로그파일에 입력하는 예제 
`ech hi 1> /dev/null 2> log.file`

## 명령 역따옴표 
* 리눅스 명령을 넣으면 결과 반환
* 예제
 
`\`echo expr 1 = 3\``


## 쉘 내부에서 또 다른 쉘 실행시키기
* 보통 아무생각없이 쉘 내부에서 다른 쉘을 실행시키는 경우가 있다. 이런 경우 내부에서 실행되는 쉘이 제대로 실행되지 않을 경우가 있다.
* 쉘프로그램에 익숙하지 않아서 원인을 정확히 파악하지는 못했다.
* 예를들어 DB 도커 컨테이너가 있다고 하자. 볼륨설정은 못하고 이미 데이터가 많이 쌓인 경우 운영을 계속하려면 백업을 주기적으로 해야한다.
* 이 때 다음과 같이 명령을 실행하여 DB를 백업할 수 있다(여기에선 MariaDB를 사용한다고 가정하자.)
- `docker exec -it container_name mysqldump -uuser_name -ppasswd db_name > backup.sql`
* 직접실행할 때는 `-i`나 `-t` 옵션을 넣어도 상관이 없는 것 같다.
* 어쨌든 이 작업을 `crontab`에게 넘겨주기 위해서 쉘 스크립트를 작성해야한다. 만약 위 내용을 그대로 쉘스크립트에 넣으면 제대로 동작하지 않음을 알 수 있다.
* 내가 알아낸 이유는 쉘 내부에서 또 다른 쉘을 실행시는 것이기 때문이다. 위 예에서는 mysqldump는 컨테이너 내부의 쉘에서 실행된다.
* 물론 위 명령을 직접 실행하면 문제는 없지만  cron -> host shell -> container shell 이렇게 3단계부터는 문제가 생겼다.(경험상, 이유는 모름)
* 따라서 이럴 땐  `-c` 커맨드 옵션을 통해서 내부에서 실행되는 쉘을 실행히키면 문제는 해결된다. 
- `docker exec -it container_name bash -c "mysqldump -uuser_name -ppasswd db_name > backup.sql"`
- 위 명령은`the input device is not a TTY` 에러를 발생시킨다. `-it` 옵션을 제거하면 해결된다.
* 그런데 위와 같이 실행할 경우 `backup.sql`이 컨테이너 내부에 생성된다. 이전 명령은 호스트에 `backup.sql`이 생성되는데 말이다.
* 이유는 -c 옵션 뒤 명령은 컨테이너 쉘에서 모두 실행되기 때문이다. 
* 따라서 이를 해결하려면 컨테이너 내부에 백업파일을 우선 저장해 놓고, 그 뒤에 `docker cp` 명령으로 `backup.sql`을 외부로 빼내면 된다.
- `docker cp container_name:/file/path/backup.sql /home/my/db/`
  


